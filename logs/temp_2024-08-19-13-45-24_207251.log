INFO:root:log file created!
INFO:root:Start time: 2024-08-19 13:45:24.495199
INFO:root:LLM default prompt size: 274
INFO:root:C code :



double linear_interp(double x,double lx,double ux,double ly,double uy) {
  return((x-lx)/(ux-lx)*(uy-ly)+ly);
}
INFO:root:x86 code: 

.globl linear_interp
.type linear_interp, @function
linear_interp:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movsd	%xmm0, -8(%rbp)
	movsd	%xmm1, -16(%rbp)
	movsd	%xmm2, -24(%rbp)
	movsd	%xmm3, -32(%rbp)
	movsd	%xmm4, -40(%rbp)
	movsd	-8(%rbp), %xmm0
	subsd	-16(%rbp), %xmm0
	movapd	%xmm0, %xmm1
	movsd	-24(%rbp), %xmm0
	subsd	-16(%rbp), %xmm0
	divsd	%xmm0, %xmm1
	movapd	%xmm1, %xmm0
	mulsd	-40(%rbp), %xmm0
	addsd	-32(%rbp), %xmm0
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 100.0%
INFO:root:CASE 0 failed
INFO:root:C code :

double QuinticEaseIn(double p)
{
    return p * p * p * p * p;
}
INFO:root:x86 code: 

.globl QuinticEaseIn
.type QuinticEaseIn, @function
QuinticEaseIn:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movsd	%xmm0, -8(%rbp)
	movsd	-8(%rbp), %xmm0
	mulsd	%xmm0, %xmm0
	mulsd	-8(%rbp), %xmm0
	mulsd	-8(%rbp), %xmm0
	mulsd	-8(%rbp), %xmm0
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 1 succeeded
INFO:root:C code :
#include <stdio.h>

int dec_lv(char x, char c, int lv)
{
 if (x == c)
  --lv;

 return lv;
}
INFO:root:x86 code: 

.globl dec_lv
.type dec_lv, @function
dec_lv:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%esi, %ecx
	movl	%edx, %eax
	movl	%edi, %edx
	movb	%dl, -4(%rbp)
	movl	%ecx, %edx
	movb	%dl, -8(%rbp)
	movl	%eax, -12(%rbp)
	movzbl	-4(%rbp), %eax
	cmpb	-8(%rbp), %al
	jne	.L2
	subl	$1, -12(%rbp)
.L2:
	movl	-12(%rbp), %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 2 succeeded
INFO:root:C code :
#include <stdio.h>

#include <string.h>

#include <stdlib.h>

#include <unistd.h>

#include <limits.h>

#include <errno.h>

#include <stdarg.h>

#include <fcntl.h>

#include <time.h>

#include <signal.h>

#include <dirent.h>

#include <pwd.h>

#include <sys/types.h>

#include <sys/stat.h>

#include <sys/wait.h>

int
prefix_of(char *special, char *s)
{
 for (; *special != '\0'; ++special)
  if (*special != *s++)
   return 0;
 return (*s == '=' || *s == '\0');
}
INFO:root:x86 code: 

.globl prefix_of
.type prefix_of, @function
prefix_of:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -8(%rbp)
	movq	%rsi, -16(%rbp)
	jmp	.L2
.L5:
	movq	-8(%rbp), %rax
	movzbl	(%rax), %edx
	movq	-16(%rbp), %rax
	leaq	1(%rax), %rcx
	movq	%rcx, -16(%rbp)
	movzbl	(%rax), %eax
	cmpb	%al, %dl
	je	.L3
	movl	$0, %eax
	jmp	.L4
.L3:
	addq	$1, -8(%rbp)
.L2:
	movq	-8(%rbp), %rax
	movzbl	(%rax), %eax
	testb	%al, %al
	jne	.L5
	movq	-16(%rbp), %rax
	movzbl	(%rax), %eax
	cmpb	$61, %al
	je	.L6
	movq	-16(%rbp), %rax
	movzbl	(%rax), %eax
	testb	%al, %al
	jne	.L7
.L6:
	movl	$1, %eax
	jmp	.L4
.L7:
	movl	$0, %eax
.L4:
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 3 succeeded
INFO:root:C code :
#include <stdio.h>

#include <stdlib.h>

#include <memory.h>

int* sub(int* a, int sizeA, int* b, int sizeB, int* resultSize){

}
INFO:root:x86 code: 

.globl sub
.type sub, @function
sub:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -8(%rbp)
	movl	%esi, -12(%rbp)
	movq	%rdx, -24(%rbp)
	movl	%ecx, -16(%rbp)
	movq	%r8, -32(%rbp)
	nop
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 4 succeeded
INFO:root:C code :

void vec_mpy(int y[], const short x[], short scaler)
{
 int i;

 for (i = 0; i < 150; i++)
   y[i] += ((scaler * x[i]) >> 31);
}
INFO:root:x86 code: 

.globl vec_mpy
.type vec_mpy, @function
vec_mpy:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -24(%rbp)
	movq	%rsi, -32(%rbp)
	movl	%edx, %eax
	movw	%ax, -36(%rbp)
	movl	$0, -4(%rbp)
	jmp	.L2
.L3:
	movl	-4(%rbp), %eax
	cltq
	leaq	(%rax,%rax), %rdx
	movq	-32(%rbp), %rax
	addq	%rdx, %rax
	movzwl	(%rax), %eax
	movswl	%ax, %edx
	movswl	-36(%rbp), %eax
	imull	%edx, %eax
	sarl	$31, %eax
	movl	%eax, %ecx
	movl	-4(%rbp), %eax
	cltq
	leaq	0(,%rax,4), %rdx
	movq	-24(%rbp), %rax
	addq	%rdx, %rax
	movl	(%rax), %edx
	movl	-4(%rbp), %eax
	cltq
	leaq	0(,%rax,4), %rsi
	movq	-24(%rbp), %rax
	addq	%rsi, %rax
	addl	%ecx, %edx
	movl	%edx, (%rax)
	addl	$1, -4(%rbp)
.L2:
	cmpl	$149, -4(%rbp)
	jle	.L3
	nop
	nop
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 5 succeeded
INFO:root:C code :

int sign_int(int num)
{
  return (( ((((num))) <= (((0)))) ? ( ((((num))) < (((0)))) ? ((-1)) : ((0)) ) : ((1)) ));
}
INFO:root:x86 code: 

.globl sign_int
.type sign_int, @function
sign_int:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	$0, %eax
	cmpl	$0, -4(%rbp)
	setle	%al
	movzbl	%al, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 100.0%
INFO:root:CASE 6 failed
INFO:root:C code :

int big_endian(
    void)
{
    union {
        long l;
        char c[sizeof(long)];
    } u;

    u.l = 1;

    return (u.c[sizeof(long) - 1] == 1);
}
INFO:root:x86 code: 

.globl big_endian
.type big_endian, @function
big_endian:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$32, %rsp
	movq	%fs:40, %rax
	movq	%rax, -8(%rbp)
	xorl	%eax, %eax
	movq	$1, -16(%rbp)
	movzbl	-9(%rbp), %eax
	cmpb	$1, %al
	sete	%al
	movzbl	%al, %eax
	movq	-8(%rbp), %rdx
	xorq	%fs:40, %rdx
	je	.L3
	call	__stack_chk_fail@PLT
.L3:
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 7 succeeded
INFO:root:C code :

int _isatty(int fd)
{
  (void)fd;
  return (1);
}
INFO:root:x86 code: 

.globl _isatty
.type _isatty, @function
_isatty:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	$1, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 8 succeeded
INFO:root:C code :

extern inline int
JKMarray_idx (const int J, const int K, const int M)
{
  return (((4 * J * J + 5) * J) / 3 + 2 * J * J + K * (2 * J + 1) + M);
}
INFO:root:x86 code: 

.globl JKMarray_idx
.type JKMarray_idx, @function
JKMarray_idx:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	%esi, -8(%rbp)
	movl	%edx, -12(%rbp)
	movl	-4(%rbp), %eax
	imull	%eax, %eax
	movl	%eax, %edx
	movl	%edx, %eax
	sall	$2, %eax
	addl	%edx, %eax
	addl	$5, %eax
	imull	-4(%rbp), %eax
	movslq	%eax, %rdx
	imulq	$-1840700269, %rdx, %rdx
	shrq	$32, %rdx
	sarl	$2, %edx
	sarl	$31, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	imull	-4(%rbp), %eax
	leal	(%rax,%rax), %edx
	movl	-4(%rbp), %eax
	addl	%eax, %eax
	addl	%eax, %edx
	movl	-8(%rbp), %eax
	addl	%eax, %edx
	movl	-12(%rbp), %eax
	addl	%edx, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 90.0%
INFO:root:CASE 9 failed
INFO:root:C code :

long sign_long(long num)
{
  return (( ((((num))) <= (((0)))) ? ( ((((num))) < (((0)))) ? ((-1)) : ((0)) ) : ((1)) ));
}
INFO:root:x86 code: 

.globl sign_long
.type sign_long, @function
sign_long:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -8(%rbp)
	movq	-8(%rbp), %rax
	cmpq	$0, %rax
	jle	.L2
	movl	$1, %eax
	jmp	.L4
.L2:
	movq	-8(%rbp), %rax
	testq	%rax, %rax
	jns	.L5
	movl	$-1, %eax
	jmp	.L4
.L5:
	movl	$0, %eax
.L4:
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 10 succeeded
INFO:root:C code :

int dmp_cm_edit_config(void)
{
 return 0;
}
INFO:root:x86 code: 

.globl dmp_cm_edit_config
.type dmp_cm_edit_config, @function
dmp_cm_edit_config:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 11 succeeded
INFO:root:C code :

int _cmp (int _a, int _b) {
 int a = _a;
 int b = _b;
 return (a > b ? (-1) : (1));
}
INFO:root:x86 code: 

.globl _cmp
.type _cmp, @function
_cmp:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -20(%rbp)
	movl	%esi, -24(%rbp)
	movl	-20(%rbp), %eax
	movl	%eax, -8(%rbp)
	movl	-24(%rbp), %eax
	movl	%eax, -4(%rbp)
	movl	-8(%rbp), %eax
	cmpl	-4(%rbp), %eax
	jle	.L2
	movl	$-1, %eax
	jmp	.L4
.L2:
	movl	$1, %eax
.L4:
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 12 succeeded
INFO:root:C code :

int safe(void) {
    extern int q;
    int lp;
    return 0;
}
INFO:root:x86 code: 

.globl safe
.type safe, @function
safe:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 13 succeeded
INFO:root:C code :

int HelpItem146( void )
{

 return 0;
}
INFO:root:x86 code: 

.globl HelpItem146
.type HelpItem146, @function
HelpItem146:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 14 succeeded
INFO:root:C code :

int update_program_status(int aggregated_dump) {}
INFO:root:x86 code: 

.globl update_program_status
.type update_program_status, @function
update_program_status:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	nop
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 15 succeeded
INFO:root:C code :
#include <stdlib.h>

int printArray(int arr[], int n)
{
    int i=1;
    while(arr[i]==arr[0])
    {
        i++;
    }
    return i;
}
INFO:root:x86 code: 

.globl printArray
.type printArray, @function
printArray:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -24(%rbp)
	movl	%esi, -28(%rbp)
	movl	$1, -4(%rbp)
	jmp	.L2
.L3:
	addl	$1, -4(%rbp)
.L2:
	movl	-4(%rbp), %eax
	cltq
	leaq	0(,%rax,4), %rdx
	movq	-24(%rbp), %rax
	addq	%rdx, %rax
	movl	(%rax), %edx
	movq	-24(%rbp), %rax
	movl	(%rax), %eax
	cmpl	%eax, %edx
	je	.L3
	movl	-4(%rbp), %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 16 succeeded
INFO:root:C code :

int
COLORS()
{

    return 256;
}
INFO:root:x86 code: 

.globl COLORS
.type COLORS, @function
COLORS:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$256, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 17 succeeded
INFO:root:C code :

int bar( int x )
{
   return x+1;
}
INFO:root:x86 code: 

.globl bar
.type bar, @function
bar:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	-4(%rbp), %eax
	addl	$1, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 18 succeeded
INFO:root:C code :
#include <stdio.h>

#include <time.h>

#include <string.h>

#include <stdlib.h>

#include <assert.h>

char *skipSpaces(char *pc)
{
 while((*pc == ' ' || *pc == '\n' || *pc == '\t' || *pc == '\r') &&
   *pc != '\0')
  pc++;

 return pc;
}
INFO:root:x86 code: 

.globl skipSpaces
.type skipSpaces, @function
skipSpaces:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -8(%rbp)
	jmp	.L2
.L4:
	addq	$1, -8(%rbp)
.L2:
	movq	-8(%rbp), %rax
	movzbl	(%rax), %eax
	cmpb	$32, %al
	je	.L4
	movq	-8(%rbp), %rax
	movzbl	(%rax), %eax
	cmpb	$10, %al
	je	.L4
	movq	-8(%rbp), %rax
	movzbl	(%rax), %eax
	cmpb	$9, %al
	je	.L4
	movq	-8(%rbp), %rax
	movzbl	(%rax), %eax
	cmpb	$13, %al
	je	.L4
	movq	-8(%rbp), %rax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 19 succeeded
INFO:root:C code :

char *init_buffer(char *buffer)
{
 int i;

 i = 0;
 while (buffer[i])
  buffer[i++] = 0;
 return (buffer);
}
INFO:root:x86 code: 

.globl init_buffer
.type init_buffer, @function
init_buffer:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -24(%rbp)
	movl	$0, -4(%rbp)
	jmp	.L2
.L3:
	movl	-4(%rbp), %eax
	leal	1(%rax), %edx
	movl	%edx, -4(%rbp)
	movslq	%eax, %rdx
	movq	-24(%rbp), %rax
	addq	%rdx, %rax
	movb	$0, (%rax)
.L2:
	movl	-4(%rbp), %eax
	movslq	%eax, %rdx
	movq	-24(%rbp), %rax
	addq	%rdx, %rax
	movzbl	(%rax), %eax
	testb	%al, %al
	jne	.L3
	movq	-24(%rbp), %rax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 20 succeeded
INFO:root:C code :

int GetAnswer() {
  return 42;
}
INFO:root:x86 code: 

.globl GetAnswer
.type GetAnswer, @function
GetAnswer:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$42, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 21 succeeded
INFO:root:C code :

unsigned char padding(void)
{
  return 0xff;
}
INFO:root:x86 code: 

.globl padding
.type padding, @function
padding:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$255, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 22 succeeded
INFO:root:C code :
#include <stdio.h>

#include <stdlib.h>

int getPrec(char op) {

    switch(op) {
        case '+':
        case '-':
        return 1;

        case '*':
        case '/':
        return 2;


        case '(':
        case ')':
        return 3;

        default:
        return 0;
    }
}
INFO:root:x86 code: 

.globl getPrec
.type getPrec, @function
getPrec:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, %eax
	movb	%al, -4(%rbp)
	movsbl	-4(%rbp), %eax
	subl	$40, %eax
	cmpl	$20, %eax
	ja	.L2
	movl	%eax, %eax
	leaq	0(,%rax,4), %rdx
	leaq	.L4(%rip), %rax
	movl	(%rdx,%rax), %eax
	cltq
	leaq	.L4(%rip), %rdx
	addq	%rdx, %rax
	notrack jmp	*%rax
	.section	.rodata
	.align 4
	.align 4
.L4:
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.L2-.L4
	.long	.
WARNING:root:CASE 23 failed to assemble the code to executable!
WARNING:root:ret.stderr: tmp.s: Assembler messages:
tmp.s: Warning: end of file not at end of a line; newline inserted
tmp.s: Error: open CFI at the end of file; missing .cfi_endproc directive

WARNING:root:ret.stdout: 
INFO:root:C code :
#include <sys/stat.h>

#include <errno.h>

#include <sys/times.h>

int _isatty(int file)
{
  return 0;
}
INFO:root:x86 code: 

.globl _isatty
.type _isatty, @function
_isatty:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 24 succeeded
INFO:root:C code :
#include <stdlib.h>

#include <stdio.h>

#include <string.h>

#include <errno.h>

char flip_bit (char bit_character) {
 if ('0' == bit_character)
  return '1';
 else
  return '0';
}
INFO:root:x86 code: 

.globl flip_bit
.type flip_bit, @function
flip_bit:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, %eax
	movb	%al, -4(%rbp)
	cmpb	$48, -4(%rbp)
	jne	.L2
	movl	$49, %eax
	jmp	.L3
.L2:
	movl	$48, %eax
.L3:
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 25 succeeded
INFO:root:C code :

int
foo (int a, int b)
{
  int t;

  if (b)
    {
      if (a)
 t = 3;
      else
 t = 5;

      a = 0;
    }
  else
    t = 7;

  return t;
}
INFO:root:x86 code: 

.globl foo
.type foo, @function
foo:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -20(%rbp)
	movl	%esi, -24(%rbp)
	cmpl	$0, -24(%rbp)
	je	.L2
	cmpl	$0, -20(%rbp)
	je	.L3
	movl	$3, -4(%rbp)
	jmp	.L4
.L3:
	movl	$5, -4(%rbp)
.L4:
	movl	$0, -20(%rbp)
	jmp	.L5
.L2:
	movl	$7, -4(%rbp)
.L5:
	movl	-4(%rbp), %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 26 succeeded
INFO:root:C code :
#include <math.h>

#include <stddef.h>

double opTimes(double lhs, double rhs) { return lhs * rhs; }
INFO:root:x86 code: 

.globl opTimes
.type opTimes, @function
opTimes:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movsd	%xmm0, -8(%rbp)
	movsd	%xmm1, -16(%rbp)
	movsd	-8(%rbp), %xmm0
	mulsd	-16(%rbp), %xmm0
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 27 succeeded
INFO:root:C code :

float raw_linear_derivative_at( float y ) {
  return 1.0;
}
INFO:root:x86 code: 

.globl raw_linear_derivative_at
.type raw_linear_derivative_at, @function
raw_linear_derivative_at:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movss	%xmm0, -4(%rbp)
	movss	.LC0(%rip), %xmm0
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LC0: 	.long	1065353216


INFO:root:Local error rate: 0.0%
INFO:root:CASE 28 succeeded
INFO:root:C code :

int bitCount(int x) {
  return 2;
}
INFO:root:x86 code: 

.globl bitCount
.type bitCount, @function
bitCount:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	$2, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 29 succeeded
INFO:root:C code :



















int xtoi(char *p)
{
 int curr;
 int res = 0;

 while (*p)
 {
  curr = ((*p) >= '0' && (*p) <= '9' ? (*p) - '0' : (*p) >= 'A' && (*p) <= 'F' ? (*p) - 'A' + 10 : (*p) >= 'a' && (*p) <= 'f' ? (*p) - 'a' + 10 : -1);
  if (curr == -1) break;
  res = res * 0x10 + curr;
  p++;
 }

 return res;
}
INFO:root:x86 code: 

.globl xtoi
.type xtoi, @function
xtoi:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -24(%rbp)
	movl	$0, -4(%rbp)
	jmp	.L2
.L11:
	movq	-24(%rbp), %rax
	movzbl	(%rax), %eax
	cmpb	$47, %al
	jle	.L3
	movq	-24(%rbp), %rax
	movzbl	(%rax), %eax
	cmpb	$57, %al
	jg	.L3
	movq	-24(%rbp), %rax
	movzbl	(%rax), %eax
	movsbl	%al, %eax
	subl	$48, %eax
	jmp	.L4
.L3:
	movq	-24(%rbp), %rax
	movzbl	(%rax), %eax
	cmpb	$64, %al
	jle	.L5
	movq	-24(%rbp), %rax
	movzbl	(%rax), %eax
	cmpb	$70, %al
	jg	.L5
	movq	-24(%rbp), %rax
	movzbl	(%rax), %eax
	movsbl	%al, %eax
	subl	$55, %eax
	jmp	.L4
.L5:
	movq	-24(%rbp), %rax
	movzbl	(%rax), %eax
	cmpb	$96, %al
	jle	.L6
	movq	-24(%rbp), %rax
	movzbl	(%rax), %eax
	cmpb	$102, %al
	jg	.L6
	movq	-24(%rbp), %rax
	movzbl	(%rax), %eax
	movsbl	%al, %eax
	subl	$87, %eax
	jmp	.L4
.L6:
	movl	$-1, %eax
.L4:
	movl	%eax, -8(%rbp)
	cmpl	$-1, -8(%rbp)
	je	.L12
	movl	-4(%rbp), %eax
	sall	$4, %eax
	movl	%eax, %edx
	movl	-8(%rbp), %eax
	addl	%edx, %eax
	movl	%eax, -4(%rbp)
	addq	$1, -24(%rbp)
.L2:
	movq	-24(%rbp), %rax
	movzbl	(%rax), %eax
	testb	%al, %al
	jne	.L11
	jmp	.L9
.L12:
	nop
.L9:
	movl	-4(%rbp), %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 30 succeeded
INFO:root:C code :
#include <string.h>

#include <stdlib.h>

#include <assert.h>

int DummyCDInit(__attribute ((unused)) const char *cdrom_name)
{



 return 0;
}
INFO:root:x86 code: 

.globl DummyCDInit
.type DummyCDInit, @function
DummyCDInit:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -8(%rbp)
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 31 succeeded
INFO:root:C code :
#include <stdio.h>

#include <time.h>

#include <stdlib.h>

#include <ctype.h>

int retPosVector(char letra, char alfabeto[]) {
 int i;

 for( i = 0; alfabeto[i]; i++) {
  if(alfabeto[i] == letra) {
   return i;
  }
 }
}
INFO:root:x86 code: 

.globl retPosVector
.type retPosVector, @function
retPosVector:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, %eax
	movq	%rsi, -32(%rbp)
	movb	%al, -20(%rbp)
	movl	$0, -4(%rbp)
	jmp	.L2
.L5:
	movl	-4(%rbp), %eax
	movslq	%eax, %rdx
	movq	-32(%rbp), %rax
	addq	%rdx, %rax
	movzbl	(%rax), %eax
	cmpb	%al, -20(%rbp)
	jne	.L3
	movl	-4(%rbp), %eax
	jmp	.L4
.L3:
	addl	$1, -4(%rbp)
.L2:
	movl	-4(%rbp), %eax
	movslq	%eax, %rdx
	movq	-32(%rbp), %rax
	addq	%rdx, %rax
	movzbl	(%rax), %eax
	testb	%al, %al
	jne	.L5
.L4:
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 32 succeeded
INFO:root:C code :

unsigned int CgosStrLen(const char *s)
  {
  const char *ss=s;
  if (!s) return 0;
  while (*s++);
  return s-ss-1;
  }
INFO:root:x86 code: 

.globl CgosStrLen
.type CgosStrLen, @function
CgosStrLen:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -24(%rbp)
	movq	-24(%rbp), %rax
	movq	%rax, -8(%rbp)
	cmpq	$0, -24(%rbp)
	jne	.L2
	movl	$0, %eax
	jmp	.L3
.L2:
	movq	-24(%rbp), %rax
	leaq	1(%rax), %rdx
	movq	%rdx, -24(%rbp)
	movzbl	(%rax), %eax
	testb	%al, %al
	jne	.L2
	movq	-24(%rbp), %rax
	subq	-8(%rbp), %rax
	subq	$1, %rax
.L3:
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 33 succeeded
INFO:root:C code :
#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#include <math.h>

#include <time.h>

#include <omp.h>

#include <unistd.h>

int checkExpDesignator(char *str, int len)
{
 int i,n=0;

 for (i=0; i<len; i++)
 {
  if (str[i]=='D')
  {
   n++;
   str[i] = 'E';
  }
 }

 return(n);
}
INFO:root:x86 code: 

.globl checkExpDesignator
.type checkExpDesignator, @function
checkExpDesignator:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -24(%rbp)
	movl	%esi, -28(%rbp)
	movl	$0, -4(%rbp)
	movl	$0, -8(%rbp)
	jmp	.L2
.L4:
	movl	-8(%rbp), %eax
	movslq	%eax, %rdx
	movq	-24(%rbp), %rax
	addq	%rdx, %rax
	movzbl	(%rax), %eax
	cmpb	$68, %al
	jne	.L3
	addl	$1, -4(%rbp)
	movl	-8(%rbp), %eax
	movslq	%eax, %rdx
	movq	-24(%rbp), %rax
	addq	%rdx, %rax
	movb	$69, (%rax)
.L3:
	addl	$1, -8(%rbp)
.L2:
	movl	-8(%rbp), %eax
	cmpl	-28(%rbp), %eax
	jl	.L4
	movl	-4(%rbp), %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 34 succeeded
INFO:root:C code :
#include <stddef.h>

#include <stdint.h>

int oc_storage_config(const char *store) {
    return -1;
}
INFO:root:x86 code: 

.globl oc_storage_config
.type oc_storage_config, @function
oc_storage_config:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -8(%rbp)
	movl	$-1, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 35 succeeded
INFO:root:C code :
#include <stdio.h>

#include <stdlib.h>

int inter_mercenary_sql_init(void)
{
 return 0;
}
INFO:root:x86 code: 

.globl inter_mercenary_sql_init
.type inter_mercenary_sql_init, @function
inter_mercenary_sql_init:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 36 succeeded
INFO:root:C code :
#include <stdio.h>

int tester(int num){
 return num;
}
INFO:root:x86 code: 

.globl tester
.type tester, @function
tester:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	-4(%rbp), %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 37 succeeded
INFO:root:C code :
#include <stdio.h>

int logicOr(int x, int y) {
 if (x || y == 1) {
  return 1;
 }
 else {
  return 0;
 }
}
INFO:root:x86 code: 

.globl logicOr
.type logicOr, @function
logicOr:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	%esi, -8(%rbp)
	cmpl	$0, -4(%rbp)
	jne	.L2
	cmpl	$1, -8(%rbp)
	jne	.L3
.L2:
	movl	$1, %eax
	jmp	.L4
.L3:
	movl	$0, %eax
.L4:
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 38 succeeded
INFO:root:C code :

int f6(int c, int shamt) {




  return c << shamt;
}
INFO:root:x86 code: 

.globl f6
.type f6, @function
f6:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	%esi, -8(%rbp)
	movl	-8(%rbp), %eax
	movl	-4(%rbp), %edx
	movl	%eax, %ecx
	sall	%cl, %edx
	movl	%edx, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 39 succeeded
INFO:root:C code :
#include <stdio.h>

#include <string.h>

char cipher (char c){
 if(c >= 65 && c<= 90){
  c = c - 65;
  c = 90 - c;
 }else if( c >= 97 && c<= 122){
  c = c-97;
  c = 122 - c;
 }
 return c;
}
INFO:root:x86 code: 

.globl cipher
.type cipher, @function
cipher:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, %eax
	movb	%al, -4(%rbp)
	cmpb	$64, -4(%rbp)
	jle	.L2
	cmpb	$90, -4(%rbp)
	jg	.L2
	movzbl	-4(%rbp), %eax
	subl	$65, %eax
	movb	%al, -4(%rbp)
	movzbl	-4(%rbp), %eax
	movl	$90, %edx
	subl	%eax, %edx
	movl	%edx, %eax
	movb	%al, -4(%rbp)
	jmp	.L3
.L2:
	cmpb	$96, -4(%rbp)
	jle	.L3
	cmpb	$122, -4(%rbp)
	jg	.L3
	movzbl	-4(%rbp), %eax
	subl	$97, %eax
	movb	%al, -4(%rbp)
	movzbl	-4(%rbp), %eax
	movl	$122, %edx
	subl	%eax, %edx
	movl	%edx, %eax
	movb	%al, -4(%rbp)
.L3:
	movzbl	-4(%rbp), %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 40 succeeded
INFO:root:C code :

int
g(int a)
{
 return a;
}
INFO:root:x86 code: 

.globl g
.type g, @function
g:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	-4(%rbp), %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 41 succeeded
INFO:root:C code :

float obdConvert_44 (unsigned int A, unsigned int B, unsigned int C, unsigned int D) {
 return ((float)A*256.0f+(float)B)*0.0000305f;
}
INFO:root:x86 code: 

.globl obdConvert_44
.type obdConvert_44, @function
obdConvert_44:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	%esi, -8(%rbp)
	movl	%edx, -12(%rbp)
	movl	%ecx, -16(%rbp)
	movl	-4(%rbp), %eax
	cvtsi2ssl	%eax, %xmm0
	movss	.LC0(%rip), %xmm1
	mulss	%xmm1, %xmm0
	cvtss2sd	%xmm0, %xmm0
	movl	-8(%rbp), %eax
	cvtsi2ssl	%eax, %xmm1
	addss	%xmm1, %xmm0
	cvtss2sd	%xmm0, %xmm0
	movsd	.LC1(%rip), %xmm1
	mulsd	%xmm1, %xmm0
	cvtsd2ss	%xmm0, %xmm0
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LC0: 	.long	1120403456
.LC1: 	.long	2181038080


INFO:root:Local error rate: 100.0%
INFO:root:CASE 42 failed
INFO:root:C code :

double check_double() { return 0; }
INFO:root:x86 code: 

.globl check_double
.type check_double, @function
check_double:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movsd	.LC0(%rip), %xmm0
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LC0: 	.long	0


INFO:root:Local error rate: 100.0%
INFO:root:CASE 43 failed
INFO:root:C code :

int ft_tolower(int c)
{
 if (c <= 90 && c >= 65)
  return (c + 32);
 return (c);
}
INFO:root:x86 code: 

.globl ft_tolower
.type ft_tolower, @function
ft_tolower:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	cmpl	$90, -4(%rbp)
	jg	.L2
	cmpl	$64, -4(%rbp)
	jle	.L2
	movl	-4(%rbp), %eax
	addl	$32, %eax
	jmp	.L3
.L2:
	movl	-4(%rbp), %eax
.L3:
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 44 succeeded
INFO:root:C code :







int SwapLong(int num)
{
 return (((num >> 0) & 0xFF) << 24) + (((num >> 8) & 0xFF) << 16) + (((num >> 16) & 0xFF) << 8) + (((num >> 24) & 0xFF) << 0);
}
INFO:root:x86 code: 

.globl SwapLong
.type SwapLong, @function
SwapLong:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	-4(%rbp), %eax
	sall	$24, %eax
	movl	%eax, %edx
	movl	-4(%rbp), %eax
	sarl	$8, %eax
	movzbl	%al, %eax
	sall	$16, %eax
	addl	%eax, %edx
	movl	-4(%rbp), %eax
	sarl	$16, %eax
	movzbl	%al, %eax
	sall	$8, %eax
	addl	%eax, %edx
	movl	-4(%rbp), %eax
	sarl	$24, %eax
	movzbl	%al, %eax
	addl	%edx, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 45 succeeded
INFO:root:C code :
#include <inttypes.h>

#include <stdlib.h>

#include <limits.h>

#include <stdio.h>

#include <string.h>

#include <sqlite3.h>

int Bank_int_IsValidName(const char *Name)
{
 if( !Name ) return 0;
 while(*Name)
 {
  if( *Name == '\'' ) return 0;
  Name ++;
 }
 return 1;
}
INFO:root:x86 code: 

.globl Bank_int_IsValidName
.type Bank_int_IsValidName, @function
Bank_int_IsValidName:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -8(%rbp)
	cmpq	$0, -8(%rbp)
	jne	.L4
	movl	$0, %eax
	jmp	.L3
.L4:
	jmp	.L5
.L7:
	movq	-8(%rbp), %rax
	movzbl	(%rax), %eax
	cmpb	$39, %al
	jne	.L6
	movl	$0, %eax
	jmp	.L3
.L6:
	addq	$1, -8(%rbp)
.L5:
	movq	-8(%rbp), %rax
	movzbl	(%rax), %eax
	testb	%al, %al
	jne	.L7
	movl	$1, %eax
.L3:
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 46 succeeded
INFO:root:C code :
#include <assert.h>

#include <errno.h>

#include <fcntl.h>

#include <poll.h>

#include <signal.h>

#include <stdarg.h>

#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#include <sys/mman.h>

#include <sys/time.h>

#include <sys/types.h>

#include <sys/wait.h>

#include <time.h>

#include <unistd.h>

int RIFSIGNALED(int status)
{
    return (status & 0xff) != 0;
}
INFO:root:x86 code: 

.globl RIFSIGNALED
.type RIFSIGNALED, @function
RIFSIGNALED:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	-4(%rbp), %eax
	andl	$255, %eax
	testl	%eax, %eax
	setne	%al
	movzbl	%al, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 47 succeeded
INFO:root:C code :











void TextDisplaySetBarText(int barnum, const char *str)
{

}
INFO:root:x86 code: 

.globl TextDisplaySetBarText
.type TextDisplaySetBarText, @function
TextDisplaySetBarText:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movq	%rsi, -16(%rbp)
	nop
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 48 succeeded
INFO:root:C code :

char * getTokenTypeName(int type){
 switch(type){
  case 1:
   return "<LParen>";
  case 2:
   return "<RParen>";
  case 3:
   return "<Number>";
  case 8:
   return "<ID>";
  case 6:
   return "<Plus>";
  case 7:
   return "<Minus>";
  case -2:
   return "<EOF>";
  case -1:
   return "<Error!>";
  default:
   return "<Unknown token type!>";
 }
}
INFO:root:x86 code: 

.globl getTokenTypeName
.type getTokenTypeName, @function
getTokenTypeName:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	cmpl	$-2, -4(%rbp)
	je	.L2
	cmpl	$-2, -4(%rbp)
	jg	.L3
	cmpl	$-1, -4(%rbp)
	je	.L4
	cmpl	$-1, -4(%rbp)
	jg	.L3
	cmpl	$7, -4(%rbp)
	je	.L5
	cmpl	$7, -4(%rbp)
	jg	.L3
	cmpl	$6, -4(%rbp)
	je	.L6
	cmpl	$6, -4(%rbp)
	jg	.L3
	cmpl	$1, -4(%rbp)
	je	.L7
	cmpl	$2, -4(%rbp)
	je	.L8
	cmpl	$3, -4(%rbp)
	je	.L9
	cmpl	$8, -4(%rbp)
	je	.L10
	jmp	.L3
.L7:
	leaq	.LC0(%rip), %rax
	jmp	.L11
.L8:
	leaq	.LC1(%rip), %rax
	jmp	.L11
.L9:
	leaq	.LC2(%rip), %rax
	jmp	.L11
.L10:
	leaq	.LC3(%rip), %rax
	jmp	.L11
.L6:
	leaq	.LC4(%rip), %rax
	jmp	.L11
.L5:
	leaq	.LC5(%rip), %rax
	jmp	.L11
.L2:
	leaq	.LC6(%rip), %rax
	jmp	.L11
.L4:
	leaq	.LC7(%rip), %rax
	jmp	.L11
.L3:
	leaq	.LC8(%rip), %rax
.L11:
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LC4: 	.string	"<Plus>"
.LC2: 	.string	"<Number>"
.LC3: 	.string	"<ID>"
.LC5: 	.string	"<Minus>"
.LC6: 	.string	"<EOF>"
.LC7: 	.string	"<Error!>"
.LC1: 	.string	"<RParen>"
.LC0: 	.string	"<LParen>"
.LC8: 	.string	"<Unknown token type!>"


INFO:root:Local error rate: 0.0%
INFO:root:CASE 49 succeeded
INFO:root:C code :
#include <math.h>

#include <stdio.h>

#include <errno.h>

#include <stdlib.h>

int mus_iclamp(int lo, int val, int hi)
{
    if (val > hi)
        return(hi);
    else
        if (val < lo)
            return(lo);
        else return(val);
}
INFO:root:x86 code: 

.globl mus_iclamp
.type mus_iclamp, @function
mus_iclamp:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	%esi, -8(%rbp)
	movl	%edx, -12(%rbp)
	movl	-8(%rbp), %eax
	cmpl	-12(%rbp), %eax
	jle	.L2
	movl	-12(%rbp), %eax
	jmp	.L3
.L2:
	movl	-8(%rbp), %eax
	cmpl	-4(%rbp), %eax
	jge	.L4
	movl	-4(%rbp), %eax
	jmp	.L3
.L4:
	movl	-8(%rbp), %eax
.L3:
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 50 succeeded
INFO:root:C code :

float UI_ClampCvar( float min, float max, float value )
{
 if ( value < min ) return min;
 if ( value > max ) return max;
 return value;
}
INFO:root:x86 code: 

.globl UI_ClampCvar
.type UI_ClampCvar, @function
UI_ClampCvar:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movss	%xmm0, -4(%rbp)
	movss	%xmm1, -8(%rbp)
	movss	%xmm2, -12(%rbp)
	movss	-4(%rbp), %xmm0
	comiss	-12(%rbp), %xmm0
	jbe	.L2
	movss	-4(%rbp), %xmm0
	jmp	.L3
.L2:
	movss	-8(%rbp), %xmm0
	comiss	-12(%rbp), %xmm0
	jbe	.L4
	movss	-8(%rbp), %xmm0
	jmp	.L3
.L4:
	movss	-12(%rbp), %xmm0
.L3:
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 50.0%
INFO:root:CASE 51 failed
INFO:root:C code :

short USBSTK5505_GPIO_init()
{
    return 0;
}
INFO:root:x86 code: 

.globl USBSTK5505_GPIO_init
.type USBSTK5505_GPIO_init, @function
USBSTK5505_GPIO_init:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 52 succeeded
INFO:root:C code :
#include <stdio.h>

#include <math.h>

#include <stdlib.h>

#include <unistd.h>

#include <stdarg.h>

#include <string.h>

double H (double x) {
   if (x >= 0) return 1.;
   else return 0.;
}
INFO:root:x86 code: 

.globl H
.type H, @function
H:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movsd	%xmm0, -8(%rbp)
	movsd	-8(%rbp), %xmm0
	pxor	%xmm1, %xmm1
	comisd	%xmm1, %xmm0
	jb	.L2
	movsd	.LC1(%rip), %xmm0
	jmp	.L3
.L2:
	pxor	%xmm0, %xmm0
.L3:
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LC1: 	.long	0


INFO:root:Local error rate: 100.0%
INFO:root:CASE 53 failed
INFO:root:C code :































int LZ4_versionNumber (void) { return (1 *100*100 + 6 *100 + 0); }
INFO:root:x86 code: 

.globl LZ4_versionNumber
.type LZ4_versionNumber, @function
LZ4_versionNumber:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$10600, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 54 succeeded
INFO:root:C code :

int foo(int time, int n) {
#pragma omp parallel for default(shared) schedule(dynamic, 1) reduction(+ : time)
  for (int i = 1; i < n; ++i);
  return 0;
}
INFO:root:x86 code: 

.globl foo
.type foo, @function
foo:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -20(%rbp)
	movl	%esi, -24(%rbp)
	movl	$1, -4(%rbp)
	jmp	.L2
.L3:
	addl	$1, -4(%rbp)
.L2:
	movl	-4(%rbp), %eax
	cmpl	-24(%rbp), %eax
	jl	.L3
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 55 succeeded
INFO:root:C code :
#include <stdio.h>

int checkrange(char c1, char c2)
{

 if (('a' <= c1 && c1 <= 'z') && (c1 <= c2 && c2 <= 'z'))
  return 1;

 if (('A' <= c1 && c1 <= 'Z') && (c1 <= c2 && c2 <= 'Z'))
  return 1;

 if (('0' <= c1 && c1 <= '9') && (c1 <= c2 && c2 <= '9'))
  return 1;

 return 0;
}
INFO:root:x86 code: 

.globl checkrange
.type checkrange, @function
checkrange:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, %edx
	movl	%esi, %eax
	movb	%dl, -4(%rbp)
	movb	%al, -8(%rbp)
	cmpb	$96, -4(%rbp)
	jle	.L2
	cmpb	$122, -4(%rbp)
	jg	.L2
	cmpb	-8(%rbp), %al
	jg	.L2
	cmpb	$122, -8(%rbp)
	jle	.L3
.L2:
	movl	$0, %eax
	jmp	.L4
.L3:
	cmpb	$64, -4(%rbp)
	jle	.L5
	cmpb	$90, -4(%rbp)
	jg	.L5
	cmpb	-8(%rbp), %al
	jg	.L5
	cmpb	$90, -8(%rbp)
	jle	.L6
.L5:
	movl	$0, %eax
	jmp	.L4
.L6:
	cmpb	$47, -4(%rbp)
	jle	.L7
	cmpb	$57, -4(%rbp)
	jg	.L7
	cmpb	-8(%rbp), %al
	jg	.L7
	cmpb	$57, -8(%rbp)
	jle	.L8
.L7:
	movl	$0, %eax
	jmp	.L4
.L8:
	movl	$1, %eax
.L4:
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 56 succeeded
INFO:root:C code :
#include <math.h>

double
gsl_coerce_double (const double x)
{
  volatile double y;
  y = x;
  return y;
}
INFO:root:x86 code: 

.globl gsl_coerce_double
.type gsl_coerce_double, @function
gsl_coerce_double:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movsd	%xmm0, -24(%rbp)
	movsd	-24(%rbp), %xmm0
	movsd	%xmm0, -8(%rbp)
	movsd	-8(%rbp), %xmm0
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 57 succeeded
INFO:root:C code :
#include <stdio.h>

int c059(void) { return 0; }
INFO:root:x86 code: 

.globl c059
.type c059, @function
c059:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 58 succeeded
INFO:root:C code :
#include <math.h>

#include <stdlib.h>

double mcdrag_rpm(double twist, double velocity)
{
  return (velocity/(twist/60.0)*12.0);
}
INFO:root:x86 code: 

.globl mcdrag_rpm
.type mcdrag_rpm, @function
mcdrag_rpm:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movsd	%xmm0, -8(%rbp)
	movsd	%xmm1, -16(%rbp)
	movsd	-8(%rbp), %xmm0
	movsd	.LC0(%rip), %xmm1
	divsd	%xmm1, %xmm0
	mulsd	.LC1(%rip), %xmm0
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LC0: 	.long	0
.LC1: 	.long	0


INFO:root:Local error rate: 100.0%
INFO:root:CASE 59 failed
INFO:root:C code :
#include    <stdlib.h>  /* Include standard library header */

#include    <math.h>    /* Include math library header */

#include    <string.h>  /* Include string function header */

#include    <ctype.h>   /* Include character function header */

#include    <limits.h>  /* define LONG_MIN and LONG_MAX */

int valid_serial(char *carray)
{
int i, code, num[10], sumo=0, sume=0, sumss=0;

for(i=0;i<10;i++){
  code = carray[i];
  num[i] = code - 0x30;
  if((code<0x30)||(code>0x39)){
    return 0;
  }
}

sumo = num[0]+num[2]+num[4];
sumo = sumo - (sumo/10)*10;

sume = num[1]+num[3]+num[5];
sume = sume - (sume/10)*10;

sumss = num[0]+num[1]+num[2]+num[3]+num[4]+num[5]+sumo+sume;

if((sumo!=num[6])||(sume!=num[7])||(sumss!=(10*num[8]+num[9]))){
  return 0;
}

return 1;
}
INFO:root:x86 code: 

.globl valid_serial
.type valid_serial, @function
valid_serial:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$112, %rsp
	movq	%rdi, -104(%rbp)
	movq	%fs:40, %rax
	movq	%rax, -8(%rbp)
	xorl	%eax, %eax
	movl	$0, -84(%rbp)
	movl	$0, -80(%rbp)
	movl	$0, -76(%rbp)
	movl	$0, -88(%rbp)
	jmp	.L2
.L6:
	movl	-88(%rbp), %eax
	movslq	%eax, %rdx
	movq	-104(%rbp), %rax
	addq	%rdx, %rax
	movzbl	(%rax), %eax
	movsbl	%al, %eax
	movl	%eax, -72(%rbp)
	movl	-72(%rbp), %eax
	subl	$48, %eax
	movl	%eax, %edx
	movl	-88(%rbp), %eax
	cltq
	movl	%edx, -64(%rbp,%rax,4)
	cmpl	$47, -72(%rbp)
	jle	.L3
	cmpl	$57, -72(%rbp)
	jle	.L4
.L3:
	movl	$0, %eax
	jmp	.L7
.L4:
	addl	$1, -88(%rbp)
.L2:
	cmpl	$9, -88(%rbp)
	jle	.L6
	movl	-64(%rbp), %edx
	movl	-60(%rbp), %eax
	addl	%eax, %edx
	movl	-56(%rbp), %eax
	addl	%edx, %eax
	movl	%eax, -84(%rbp)
	movl	-84(%rbp), %eax
	movslq	%eax, %rdx
	imulq	$1717986919, %rdx, %rdx
	shrq	$32, %rdx
	sarl	$2, %edx
	sarl	$31, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	imull	$10, %eax, %edx
	movl	%edx, %eax
	subl	%eax, -84(%rbp)
	movl	-68(%rbp), %edx
	movl	-64(%rbp), %eax
	addl	%eax, %edx
	movl	-60(%rbp), %eax
	addl	%edx, %eax
	movl	%eax, -80(%rbp)
	movl	-80(%rbp), %eax
	movslq	%eax, %rdx
	imulq	$1717986919, %rdx, %rdx
	shrq	$32, %rdx
	sarl	$2, %edx
	sarl	$31, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	imull	$10, %eax, %edx
	movl	%edx, %eax
	subl	%eax, -80(%rbp)
	movl	-64(%rbp), %edx
	movl	-68(%rbp), %eax
	addl	%eax, %edx
	movl	-60(%rbp), %eax
	addl	%eax, %edx
	movl	-56(%rbp), %eax
	addl	%eax, %edx
	movl	-52(%rbp), %eax
	addl	%eax, %edx
	movl	-48(%rbp), %eax
	addl	%eax, %edx
	movl	-44(%rbp), %eax
	addl	%eax, %edx
	movl	-40(%rbp), %eax
	addl	%eax, %edx
	movl	-84(%rbp), %eax
	addl	%edx, %eax
	movl	-80(%rbp), %edx
	addl	%edx, %eax
	movl	%eax, -76(%rbp)
	movl	-64(%rbp), %eax
	cltq
	movl	-64(%rbp,%rax,4), %eax
	cmpl	%eax, -68(%rbp)
	jne	.L8
	movl	-60(%rbp), %eax
	cltq
	movl	-60(%rbp,%rax,4), %eax
	cmpl	%eax, -64(%rbp)
	jne	.L8
	movl	-56(%rbp), %eax
	cltq
	movl	-56(%rbp,%rax,4), %eax
	cmpl	%eax, -52(%rbp)
	jne	.L8
	movl	-52(%rbp), %eax
	cltq
	movl	-52(%rbp,%rax,4), %eax
	cmpl	%eax, -48(%rbp)
	jne	.L8
	movl	-48(%rbp), %eax
	cltq
	movl	-48(%rbp,%rax,4), %eax
	cmpl	%eax, -44(%rbp)
	jne	.L8
	movl	-44(%rbp), %eax
	cltq
	movl	-44(%rbp,%rax,4), %eax
	cmpl	%eax, -40(%rbp)
	jne	.L8
	movl	-40(%rbp), %eax
	cltq
	movl	-40(%rbp,%rax,4), %eax
	cmpl	%eax, -36(%rbp)
	jne	.L8
	movl	-36(%rbp), %eax
	cltq
	movl	-36(%rbp,%rax,4), %eax
	cmpl	%eax, -32(%rbp)
	jne	.L8
	movl	-32(%rbp), %eax
	cltq
	movl	-32(%rbp,%rax,4), %eax
	cmpl	%eax, -28(%rbp)
	jne	.L8
	movl	-28(%rbp), %eax
	cltq
	movl	-28(%rbp,%rax,4), %eax
	cmpl	%eax, -24(%rbp)
	jne	.L8
	movl	-24(%rbp), %eax
	cltq
	movl	-24(%rbp,%rax,4), %eax
	cmpl	%eax, -20(%rbp)
	jne	.L8
	movl	-20(%rbp), %eax
	cltq
	movl	-20(%rbp,%rax,4), %eax
	cmpl	%eax, -16(%rbp)
	jne	.L8
	movl	-16(%rbp), %eax
	cltq
	movl	-16(%rbp,%rax,4), %eax
	cmpl	%eax, -12(%rbp)
	jne	.L8
	movl	-12(%rbp), %eax
	cltq
	movl	-12(%rbp,%rax,4), %eax
	cmpl	%eax, -8(%rbp)
	jne	.L8
	movl	-8(%rbp), %eax
	cltq
	movl	-8(%rbp,%rax,4), %eax
	cmpl	%eax, -76(%rbp)
	je	.
WARNING:root:CASE 60 failed to assemble the code to executable!
WARNING:root:ret.stderr: tmp.s: Assembler messages:
tmp.s: Warning: end of file not at end of a line; newline inserted
tmp.s: Error: open CFI at the end of file; missing .cfi_endproc directive

WARNING:root:ret.stdout: 
INFO:root:C code :

int f(int x) { return x - 5; }
INFO:root:x86 code: 

.globl f
.type f, @function
f:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	-4(%rbp), %eax
	subl	$5, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 61 succeeded
INFO:root:C code :
#include <stdbool.h>

bool timeout_reached(void)
{
    return false;
}
INFO:root:x86 code: 

.globl timeout_reached
.type timeout_reached, @function
timeout_reached:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 62 succeeded
INFO:root:C code :
#include <string.h>

char* langRomTypeMicrosolFdc() { return "Microsol Disk Controller"; }
INFO:root:x86 code: 

.globl langRomTypeMicrosolFdc
.type langRomTypeMicrosolFdc, @function
langRomTypeMicrosolFdc:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	leaq	.LC0(%rip), %rax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LC0: 	.string	"Microsol Disk Controller"


INFO:root:Local error rate: 0.0%
INFO:root:CASE 63 succeeded
INFO:root:C code :

int do_386() { return 386; }
INFO:root:x86 code: 

.globl do_386
.type do_386, @function
do_386:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$386, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 64 succeeded
INFO:root:C code :

int function(int a, int b) { return a+b; }
INFO:root:x86 code: 

.globl function
.type function, @function
function:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	%esi, -8(%rbp)
	movl	-4(%rbp), %edx
	movl	-8(%rbp), %eax
	addl	%edx, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 65 succeeded
INFO:root:C code :
#include <stdio.h>

#include <string.h>

#include <stdlib.h>

double
UC_11_1_11
(
    double F_g_s_rep,

    double F_g_u_d

)
{
        return (F_g_s_rep / F_g_u_d);
}
INFO:root:x86 code: 

.globl UC_11_1_11
.type UC_11_1_11, @function
UC_11_1_11:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movsd	%xmm0, -8(%rbp)
	movsd	%xmm1, -16(%rbp)
	movsd	-8(%rbp), %xmm0
	divsd	-16(%rbp), %xmm0
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 66 succeeded
INFO:root:C code :
#include <stdio.h>

#include <string.h>

#include <sys/types.h>

#include <sys/stat.h>

#include <signal.h>

#include <fcntl.h>

#include <unistd.h>

#include <stdlib.h>

#include <sys/wait.h>

int stop_process(int pid)
{
 return kill(pid, 15);
}
INFO:root:x86 code: 

.globl stop_process
.type stop_process, @function
stop_process:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp
	movl	%edi, -4(%rbp)
	movl	-4(%rbp), %eax
	movl	$15, %esi
	movl	%eax, %edi
	call	kill@PLT
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 67 succeeded
INFO:root:C code :
#include <string.h>

int vout_finish(void)
{
  return 0;
}
INFO:root:x86 code: 

.globl vout_finish
.type vout_finish, @function
vout_finish:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 68 succeeded
INFO:root:C code :

int alloc(int *p)
{
  int tmp = 5;



  return 0;
}
INFO:root:x86 code: 

.globl alloc
.type alloc, @function
alloc:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -24(%rbp)
	movl	$5, -4(%rbp)
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 69 succeeded
INFO:root:C code :
#include <stdio.h>

#include <stddef.h>

#include <string.h>

char* mote64_Name(void) {
 return "MOTE64";
}
INFO:root:x86 code: 

.globl mote64_Name
.type mote64_Name, @function
mote64_Name:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	leaq	.LC0(%rip), %rax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LC0: 	.string	"MOTE64"


INFO:root:Local error rate: 0.0%
INFO:root:CASE 70 succeeded
INFO:root:C code :
#include <stdio.h>

char *hello(void) {
    return "hello";
}
INFO:root:x86 code: 

.globl hello
.type hello, @function
hello:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	leaq	.LC0(%rip), %rax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LC0: 	.string	"hello"


INFO:root:Local error rate: 0.0%
INFO:root:CASE 71 succeeded
INFO:root:C code :





int exists(const char *filename)
{
 return (0);
}
INFO:root:x86 code: 

.globl exists
.type exists, @function
exists:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -8(%rbp)
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 72 succeeded
INFO:root:C code :
#include <math.h>

float fast_cbrtf(float x)
{
   union {int ix; float x;} v;
   v.x = x;
   v.ix = v.ix/4 + v.ix/16;
   v.ix = v.ix + v.ix/16;
   v.ix = v.ix + v.ix/256;
   v.ix = 0x2a511cd0 + v.ix;
   return v.x;
}
INFO:root:x86 code: 

.globl fast_cbrtf
.type fast_cbrtf, @function
fast_cbrtf:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$32, %rsp
	movss	%xmm0, -20(%rbp)
	movss	-20(%rbp), %xmm0
	movd	%xmm0, %eax
	movl	%eax, -4(%rbp)
	movl	-4(%rbp), %eax
	sarl	$2, %eax
	movl	%eax, %edx
	movl	-4(%rbp), %eax
	sarl	$4, %eax
	addl	%edx, %eax
	movl	%eax, %edx
	movl	-4(%rbp), %eax
	addl	%edx, %eax
	movl	%eax, %edx
	movl	-4(%rbp), %eax
	addl	%edx, %eax
	movl	%eax, %edx
	movl	-4(%rbp), %eax
	addl	%edx, %eax
	movl	%eax, %edx
	movl	$715094164, %eax
	addl	%edx, %eax
	movl	%eax, %edx
	movl	-4(%rbp), %eax
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%edx, %edx
	movl	%
WARNING:root:CASE 73 failed to assemble the code to executable!
WARNING:root:ret.stderr: tmp.s: Assembler messages:
tmp.s: Warning: end of file not at end of a line; newline inserted
tmp.s:187: Error: bad register name `%'
tmp.s: Error: open CFI at the end of file; missing .cfi_endproc directive

WARNING:root:ret.stdout: 
INFO:root:C code :
#include <stddef.h>

int GO_strcmp (char *d, char *s)
{
 while ('\0' != *d) {
  if (*d != *s)
   return *d - *s;
  d++;
  s++;
 }

 return *d - *s;
}
INFO:root:x86 code: 

.globl GO_strcmp
.type GO_strcmp, @function
GO_strcmp:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -8(%rbp)
	movq	%rsi, -16(%rbp)
	jmp	.L2
.L5:
	movq	-8(%rbp), %rax
	movzbl	(%rax), %edx
	movq	-16(%rbp), %rax
	movzbl	(%rax), %eax
	cmpb	%al, %dl
	je	.L3
	movq	-8(%rbp), %rax
	movzbl	(%rax), %eax
	movsbl	%al, %edx
	movq	-16(%rbp), %rax
	movzbl	(%rax), %eax
	movsbl	%al, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	jmp	.L4
.L3:
	addq	$1, -8(%rbp)
	addq	$1, -16(%rbp)
.L2:
	movq	-8(%rbp), %rax
	movzbl	(%rax), %eax
	testb	%al, %al
	jne	.L5
	movq	-8(%rbp), %rax
	movzbl	(%rax), %eax
	movsbl	%al, %edx
	movq	-16(%rbp), %rax
	movzbl	(%rax), %eax
	movsbl	%al, %eax
	subl	%eax, %edx
	movl	%edx, %eax
.L4:
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 74 succeeded
INFO:root:C code :

int
test_01 (volatile short* x)
{
  return *x;
}
INFO:root:x86 code: 

.globl test_01
.type test_01, @function
test_01:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -8(%rbp)
	movq	-8(%rbp), %rax
	movzwl	(%rax), %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 75 succeeded
INFO:root:C code :
#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#include <ctype.h>

int isspec(char c)
{
    return (((c >= '!') && (c <= '/')) || (c >= ':' && c <= '@') || ((c >= '[') && (c <= '`')) || ((c >= '{') && (c <= 'DEL')));
}
INFO:root:x86 code: 

.globl isspec
.type isspec, @function
isspec:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, %eax
	movb	%al, -4(%rbp)
	cmpb	$32, -4(%rbp)
	jle	.L2
	cmpb	$47, -4(%rbp)
	jle	.L3
.L2:
	cmpb	$57, -4(%rbp)
	jle	.L4
	cmpb	$64, -4(%rbp)
	jle	.L3
.L4:
	cmpb	$91, -4(%rbp)
	jle	.L5
	cmpb	$96, -4(%rbp)
	jle	.L3
.L5:
	cmpb	$126, -4(%rbp)
	jle	.L6
.L3:
	movl	$1, %eax
	jmp	.L8
.L6:
	movl	$0, %eax
.L8:
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 20.0%
INFO:root:CASE 76 failed
INFO:root:C code :

int hash_val (int key)
{
    return key;
}
INFO:root:x86 code: 

.globl hash_val
.type hash_val, @function
hash_val:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	-4(%rbp), %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 77 succeeded
INFO:root:C code :
#include <stdio.h>

#include <string.h>

#include <stdlib.h>

#include <stdint.h>

#include <math.h>

int cat_nums(char *str_out, char *str){

 int i=0,j=0;
 while(str[i]!='\0'){
  if(str[i] >= '0' && str[i] <= '9'){
   str_out[j++] = str[i];
  }
  i++;
 }
 str_out[j] = '\0';
 return(j);
}
INFO:root:x86 code: 

.globl cat_nums
.type cat_nums, @function
cat_nums:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -24(%rbp)
	movq	%rsi, -32(%rbp)
	movl	$0, -8(%rbp)
	movl	$0, -4(%rbp)
	jmp	.L2
.L4:
	movl	-8(%rbp), %eax
	movslq	%eax, %rdx
	movq	-32(%rbp), %rax
	addq	%rdx, %rax
	movzbl	(%rax), %eax
	cmpb	$47, %al
	jle	.L3
	movl	-8(%rbp), %eax
	movslq	%eax, %rdx
	movq	-32(%rbp), %rax
	addq	%rdx, %rax
	movzbl	(%rax), %eax
	cmpb	$57, %al
	jg	.L3
	movl	-4(%rbp), %eax
	leal	1(%rax), %edx
	movl	%edx, -4(%rbp)
	movslq	%eax, %rdx
	movq	-24(%rbp), %rax
	addq	%rax, %rdx
	movl	-8(%rbp), %eax
	movslq	%eax, %rcx
	movq	-32(%rbp), %rax
	addq	%rcx, %rax
	movzbl	(%rax), %eax
	movb	%al, (%rdx)
.L3:
	addl	$1, -8(%rbp)
.L2:
	movl	-8(%rbp), %eax
	movslq	%eax, %rdx
	movq	-32(%rbp), %rax
	addq	%rdx, %rax
	movzbl	(%rax), %eax
	testb	%al, %al
	jne	.L4
	movl	-4(%rbp), %eax
	movslq	%eax, %rdx
	movq	-24(%rbp), %rax
	addq	%rdx, %rax
	movb	$0, (%rax)
	movl	-4(%rbp), %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 78 succeeded
INFO:root:C code :
#include <stdio.h>

#include <stdarg.h>

#include <sys/types.h>

#include <sys/stat.h>

__attribute__ ((used))
int _write(int file, char *ptr, int len)
{
# 103 "/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/LCRS-UCC/STM32F4Discovery-expansion/refs/heads/Working/OtharSoft/syscalls/syscalls.c"
    return len;
}
INFO:root:x86 code: 

.globl _write
.type _write, @function
_write:
.LFB6:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movq	%rsi, -16(%rbp)
	movl	%edx, -8(%rbp)
	movl	-8(%rbp), %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc



INFO:root:Local error rate: 0.0%
INFO:root:CASE 79 succeeded
INFO:root:C code :
#include <stdio.h>

int countVowels(char *str)
{
 int i,count=0;
 for(i=0;str[i]!='\0';++i)
  if('a' == str[i] ||
     'e' == str[i] ||
     'i' == str[i] ||
     'o' == str[i] ||
     'u' == str[i] ||
     'A' == str[i] ||
     'E' == str[i] ||
     'I' == str[i] ||
     'O' == str[i] ||
     'U' == str[i] )
   count++;
 return count;
}
